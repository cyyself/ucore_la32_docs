#### LoongArch32内存结构

地址是访问内存空间的索引。一般而言，内存地址有两个：一个是CPU通过总线访问物理内存用到的物理地址，一个是我们编写的应用程序所用到的逻辑地址（也有人称为虚拟地址）。比如如下C代码片段：
```
int boo=1;
int *foo=&a;
```
这里的boo是一个整型变量，foo变量是一个指向boo地址的整型指针变量，foo中储存的内容就是boo的逻辑地址。

LoongArch32是32位的处理器，即可以寻址的物理内存地址空间为2\^32=4G字节。为更好理解面向LoongArch32处理器的ucore操作系统，需要用到两个地址空间的概念：物理地址和逻辑地址。物理内存地址空间是处理器提交到总线上用于访问计算机系统中的内存和外设的最终地址。一个计算机系统中只有一个物理地址空间。在LoongArch32架构中，逻辑地址空间由DMW与页表机制共同配置。

这里的DMW是物理地址配置窗口，它可以直接将我们指定的物理地址的高3位转换为虚拟地址的高3位，并配置Cache一致性相关设置，显然我们可以发现，这样一个窗口的大小也就是2^(32-3) Bytes，也就是512MB。而对于内核来说，如果将内核所使用的地址空间直接映射到物理内存，那么程序编写起来更为方便。在LoongArch32架构中，DMW只有2个。

而页表机制则是现在操作系统广泛使用的一个内存管理方式，LoongArch32架构只支持4KB和4MB两种页面大小。然而这与我们熟悉的一些主流架构采用的设置一个页表基地址寄存器（如x86上的CR3），然后处理器自动在这个地址按照架构规定的页表格式进行页表的查找与TLB填充不同，LoongArch32架构采用的是软件填充TLB的方式。而当TLB中不存在我们所需要寻找的页面时，则会触发例外然后交给操作系统内核完成TLB的填充。因此相对于x86、ARM、RISC-V等架构，这一填充页表的方式效率相对较低，但易于教学使用，硬件上实现较为简单，LoongArch(不带32)则是与主流架构一样采用了硬件填充页表的方式。此外，在LoongArch32架构中采用了奇偶页表的形式，每个页面号在二进制下最低位为0和1的两个页面作为一组奇偶页面。在TLB中两个奇偶页面作为一个表项，它们可以指向不同的物理页帧，但这也导致了两个虚拟虚拟页面必须同时分配。因此为了简化该问题，uCore操作系统的LoongArch32版本采用了两个虚拟页面连续存放的方式进行。等同于将原本的4KB页面直接变成了8KB。

这里需要注意的是，DMW机制优先于页表机制。