# 实验零：操作系统实验准备

## 实验目的：

- 了解LoongArch32指令集
- 了解操作系统开发实验环境(Docker)
- 熟悉命令行方式的编译、调试工程
- 掌握基于硬件模拟器的调试技术
- 熟悉C语言编程和指针的概念
- 了解LoongArch32汇编语言

## 了解OS实验
写一个操作系统难吗？别被现在上百万行的Linux和Windows操作系统吓倒。当年Thompson乘他老婆带着小孩度假留他一人在家时，写了UNIX；当年Linus还是一个21岁大学生时完成了Linux雏形。站在这些巨人的肩膀上，我们能否也尝试一下做“巨人”的滋味呢？

MIT的Frans Kaashoek等在2006年参考PDP-11上的UNIX Version 6写了一个可在X86上跑的操作系统xv6（基于MIT License），用于学生学习操作系统。我们可以站在他们的肩膀上，基于xv6的设计，尝试着一步一步完成一个从“空空如也”到“五脏俱全”的“麻雀”操作系统—ucore，此“麻雀”包含虚存管理、进程管理、处理器调度、同步互斥、进程间通信、文件系统等主要内核功能，总的内核代码量（C+asm）不会超过5K行。充分体现了“小而全”的指导思想。

ucore的运行环境可以是真实的LoongArch32计算机，不过考虑到调试和开发的方便，我们可采用LoongArch32硬件模拟器，比如QEMU等。ucore的开发环境主要是GCC中的gcc、gas、ld和MAKE等工具，对于代码编辑则可以采用Visual Studio Code等工具。对于软件的版本控制可以采用Git、SVN等工具。而对于不熟练这些工具的同学需要在版本之间进行简单的比较也可以使用Meld等软件。调试（deubg）实验有助于发现设计中的错误，可采用gdb（配合qemu）等调试工具软件。并可整个实验的运行环境和开发环境已经使用Docker打包，推荐使用Docker来直接运行我们的环境。

那我们准备如何一步一步来实现ucore呢？根据一个操作系统的设计实现过程，我们可以有如下的实验步骤：
1. 用于了解操作系统启动前的状态和要做的准备工作，了解运行操作系统的硬件支持，理解例外，包括常规例外（例如中断、系统调用、其它异常等）与TLB例外；
2. 物理内存管理子系统，理解LoongArch32的内存管理模式，了解操作系统如何管理物理内存；
3. 虚拟内存管理子系统，通过页表机制实现TLB的填充以及缺页故障处理等；
4. 内核线程子系统，用于了解如何创建相对与用户进程更加简单的内核态线程，如果对内核线程进行动态管理等；
5. 用户进程管理子系统，用于了解用户态进程创建、执行、切换和结束的动态管理过程，了解在用户态通过系统调用得到内核态的内核服务的过程；
6. 处理器调度子系统，用于理解操作系统的调度过程和调度算法；
7. 同步互斥与进程间通信子系统，了解进程间如何进行信息交换和共享，并了解同步互斥的具体实现以及对系统性能的影响，研究死锁产生的原因，以及如何避免死锁；
8. 文件系统，了解文件系统的具体实现，与进程管理等的关系，了解缓存对操作系统IO访问的性能改进，了解虚拟文件系统（VFS）、buffer cache和disk driver之间的关系。

其中每个开发步骤都是建立在上一个步骤之上的，就像搭积木，从一个一个小木块，最终搭出来一个小房子。在搭房子的过程中，完成从理解操作系统原理到实践操作系统设计与实现的探索过程。这个房子最终的建筑架构和建设进度如下图所示：

![ucore系统结构图](../lab0_figs/image001.png "ucore系统结构图")

图1 ucore系统结构图

## 开发OS lab实验的简单步骤

1. 按照每个实验指导书中的`编译方法`部分，将Makefile中的`LAB CONFIG`区域修改为当前实验需要的部分。
2. 执行`make clean`
3. 根据指导书，参阅uCore已有代码，了解uCore中一些模块的基本工作流程，然后完成每个练习的要求。
4. 执行`make qemu -j 16`，运行当前实验，检查运行情况。其中16可以替换为你的机器的CPU线程数以达到最佳的资源利用率。
5. 若运行不成功，可以分别在两个终端中使用`make debug`与`make gdb`，使用gdb对内核进行调试。

!!! warning

    上述步骤不适用于Lab0
    